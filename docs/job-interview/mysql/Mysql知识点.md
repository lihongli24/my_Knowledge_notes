

# Mysql知识点

## mysql的基本架构

![img](./media/20180324131635747-20191129171413137.jpeg)

### 主要组件

[参考资料](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

#### 连接器

连接器主要和身份认证和权限相关的功能相关。主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。

#### 查询缓存(MySQL 8.0 版本后移除)

以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁。表中数据有更新，整个表的缓存都会失效。

#### 分析器

**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

**第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。

完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

#### 优化器

优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。

#### 执行器
当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限。

#### 存储引擎(插件式，可替换)
InnoDB/MyISAM



* 

## 存储引擎(InnoDB/MyISAM)

#### 1. InnoDB


| 文件名 | 作用 |
| ---- | ---- |
| .frm | 表的定义文件|
|  .idb| 数据文件|


* InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用
* InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。

#### 2. Myisam

| 文件名 | 作用 |
| ---- | ---- |
| .frm | 表的定义文件|
|  .MYD | 数据文件|
| .MYI | 索引文件|


* Myisam 只支持表锁
* 不支持事务
* Myisam 由于有单独的索引文件，在读取数据方面的性能很高 

#### 3. 存储结构

InnoDB 和 Myisam 都是用 B+Tree 来存储数据的。



## mysql中的各种log(redolog/undolog/binlog)

### redolog+binlog

* redolog：innoDB的实现，负责事物的持久化
* binlog: mysql统一的实现，负责归档



#### 写入顺序

1. redo log 写入，标志prepare
2. binlog写入
3. redo log 标志commit

#### 为什么要用二阶的方式

这里我们用反证法来说明下为什么要这么做？

*  **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。

*  **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

#### 异常情况下怎么恢复

假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候，机器挂了怎么办

* 判断 redo log 是否为commit ，如果判断是完整的，就立即提交。
* 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

### redolog和undolog

事务的实现




## mysql的锁 事务 隔离级别

## 索引

## 为什么使用B+tree存储数据

需要从数据存储开始讲

1. 数据存储在磁盘上，磁盘分为 盘面 >>>> 柱面 >>> 扇区

2. 从磁盘上操作请求（读 / 写）完成过程由三个动作组成：(磁盘读取慢的原因)

   - A. 寻道（时间）：磁头移动定位到指定磁道。
   - B. 旋转延迟（时间）：等待指定扇区从磁头下旋转经过。
   - C. 数据传输（时间）：数据在磁盘与内存之间的实际传输。
   
3. 根据计算机科学中著名的局部性原理，每次磁盘读取会预读一部分，。预读的长度一般为页（Page）的整数倍。(`提高io效率的方式`)
  1. 一个数据被用到时，其附近的数据一般来说也会被马上使用。
  2. 程序运行期间所需要的数据通常比较集中。
  3. 由于磁盘顺序读取的效率很高（不需要寻道时间，只需要很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。
  
4. 每个存储块称为一页（在许多操作系统中，页的大小通常为 4k），主存和磁盘以页为单位交换数据，当程序要读取的数据不在主存中时，会触发一个缺页异常。

上面讲了数据从磁盘到内存的过程，那为什么要用b+tree呢？
b+tree是N叉树(相比红黑树而言，非叶子节点能存放更多的索引)，节点存放索引，不存放数据，那么非叶子节点能在相同容量的情况下，存放更多的索引内容(相比于b-tree而言)，每次磁盘load到内存中后能容易查到数据(通过聚合索引)。

   