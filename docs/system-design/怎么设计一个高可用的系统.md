# 如何实现一个高可用的系统

## 如何抗住高并发
> 抗住高并发的诀窍，感觉都是怎么给mysql减负。只要别把mysql打挂了，差不多也就抗住了。

[参考资料](https://www.javazhiyin.com/22992.html)
### 服务的水平拆分
将某些主要的、访问量高的功能块抽出来，单独形成服务。（至少不会影响到其他的功能--比如秒杀)

### 使用缓存
mysql能支撑的并发量只能到2000左右，如果存在很高访问量的场景下，可以将一些访问量会很高的数据存储到redis缓存中，因为redis缓存能实现单机上完的访问量，如果是集群的情况，所能承受的并发量会更高。(一般使用在读的情况下)

### mq削峰
举个业务场景的栗子，秒杀业务：
上游发起下单操作
下游完成秒杀业务逻辑（库存检查，库存冻结，余额检查，余额冻结，订单生成，余额扣减，库存扣减，生成流水，余额解冻，库存解冻）
上游下单业务简单，每秒发起了10000个请求，下游秒杀业务复杂，每秒只能处理2000个请求，很有可能上游不限速的下单，导致下游系统被压垮，引发雪崩。
为了避免雪崩，常见的优化方案有两种：
1）业务上游队列缓冲，限速发送
2）业务下游队列缓冲，限速执行

> 获取mq中消息的方式使用客户端拉取的方式。
> 这样完全可以按照客户端真正的处理数据的速度来进行，保证了消费方的稳定。

### 分库分表
[谈一谈分库分表](https://zhuanlan.zhihu.com/p/54921615)
[分库分表知识](https://zhuanlan.zhihu.com/p/50650224)
单库或者单表里面的数据量越来越大，查询所需要的时间也就越来越长，势必会影响系统处理业务的效率。
#### 分库分表的方式：
1. id的区间分区方式，id<10000;10000<id<20000等(热点数据比较集中在后面的库中，)---需要原先的id是自增的
2. id的取模，对需要的分区数做取模

#### 常用的分库分表中间件
简单易用的组件：

当当sharding-jdbc
蘑菇街TSharding


强悍重量级的中间件：
sharding
TDDL Smart Client的方式（淘宝）
Atlas(Qihoo 360)
alibaba.cobar(是阿里巴巴（B2B）部门开发)
MyCAT（基于阿里开源的Cobar产品而研发）
Oceanus(58同城数据库中间件)
OneProxy(支付宝首席架构师楼方鑫开发)
vitess（谷歌开发的数据库中间件）

### 数据库数据的冷热分离
主表中存放经常会用到的字段，内容比较大的，并且不经常使用的数据可以存放在拓展表中

### 读写分离
读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

> 个人感觉需要保证实时性的数据还是得走主库。从库只是对常规的、不需要实时性的数据有效。

### 使用ElasticSearch
es天然支持分布式、支撑高并发、支持水平拓展，出现性能瓶颈的时候可以加机器。一些关联的查询可以在es中操作完，得到最终数据或者转化为msql中的主键，再去查询mysql.可以大大降低对mysql的消耗。

### 动静分离
一些静态的数据，存放在nginx或CDN节点上，不需要来访问应用服务器
[动静分离](https://zhuanlan.zhihu.com/p/51145454)

![](https://tva1.sinaimg.cn/large/00831rSTly1gclrg9senhj30h00cvt9t.jpg)
## 如何实现高可用






## 参考资料
[石杉的架构笔记里面的高可用观点](https://juejin.im/post/5bffab686fb9a04a102f0022#heading-4)
[阿里怎么抗住高并发](https://www.jianshu.com/p/9f985bbc9c70)