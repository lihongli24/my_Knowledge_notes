# 怎么设计一个高并发的系统

>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。



![](高并发系统设计.assets/006tNbRwly1g9myzd1wb3j30o50j9abe-20191206144953680.jpg)

## 设计使用到的逻辑

1. 服务拆分

   将请求量比较大的模块拆分出去，可以适当对他增加机器的负载数量

2. 缓存的使用

   因为mysql的承压能力有限，缓存能扛到上万，所以优先使用缓存放热点数据。
   需要做好缓存高可用。
   
3. mq

   1. mq削峰：将大量并发的请求，先积压在消息队列中，按照数据库能承受的数量进行处理。

4. 分库分表

   1. 讲数据量大的表进行拆分，增加查询的速度

5. 读写分离

   1. 某些实时性要求不是特别高的`读`逻辑，可以走从库

   2. 需要保障数据库主从同步的数据不丢失和同步的延时

      1. **半同步复制（解决主从复制时主库挂了复制数据丢失）** ：也叫 `semi-sync` 复制，指的就是主库写入 binlog 日志之后，就会将**强制**此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到**至少一个从库**的 ack 之后才会认为写操作完成了。

      2. **并行复制**（减少主从复制的时延）：指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后**并行重放不同库的日志**，这是库级别的并行。

         1. 查看主动复制的延时使用`show status`.查看 `Seconds_Behind_Master`，可以看到从库复制主库的数据落后了几 ms

         2. > 一般来说，如果主从延迟较为严重，有以下解决方案：
            >
            > - 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
            > - 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
            > - 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。
            > - 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法，你要是这么搞，读写分离的意义就丧失了。

6. 特定场景，比如检索等方面，可以使用天然支持分布式的ES来承担。

## 数据库的主从复制

> 主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。



![](高并发系统设计.assets/006tNbRwly1g9mzuxgjdlj30jy0byaaq-20191206144922122.jpg)